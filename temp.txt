PAGE NO:
DATE:
EX.NO:1: Implement Linear Search. Determine the time required
to search for an element. Repeat the experiment for different
values of n, the number of elements in the list to be searched and
plot a graph of the time taken versus n.
AIM:
ALGORITHM:
PAGE NO:
PROGRAM:
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
intlinear_search(intarr[],int n, int x){
int i;
clock_t start, end;
start=clock();
for(i=0;i<n;i++){
if(arr[i]==x){
end=clock();
doubletime_taken=((double)(end-start))/CLOCKS_PER_SEC;
printf("Element is present at index %d\n",i);
printf("Time Taken To Perform The Search Is :%f
seconds\n",time_taken);
return i;
}
}
end=clock();
printf("Element Is Not Present In Array\n");
return -1;
}
int main(){
}
intn,x;
printf("Enter The No Of Elements In The Array:");
scanf("%d",&n);
intarr[n];
printf("Enter %d elements :\n",n);
int i;
for(i=0;i<n;i++){
scanf("%d",&arr[i]);
}
printf("Enter The Element You Wish To Find:");
scanf("%d",&x);
linear_search(arr,n,x);
return 0;
PAGE NO:
RESULT:
PAGE NO:
PAGE NO:
DATE:
EX.NO:2 Implement recursive Binary Search. Determine the
time required to search an element. Repeat the experiment
for different values of n, the number of elements in the list
to be searched and plot a graph of the time taken versus n.
AIM:
ALGORITHM:
PAGE NO:
PROGRAM:
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
Intbinary_search(intarr[], int l, intr,int x)
{
if(r>=1)
{
int mid=l+(r-l)/2;
}
if(arr[mid]==x){
return mid;
}
if(arr[mid]>x){
returnbinary_search(arr,l,mid-1,x);
}
returnbinary_search(arr,mid+1,r,x);
}
return -1;
int main()
{
inti,n,index,x;
clock_t start, end;
doubletime_taken;
printf("Enter The Number Of The Elements In The List :");
scanf("%d",&n);
intarr[n];
printf("Enter The Element Of The List In Sorted Order :\n");
for(i=0;i<n;i++)
{
scanf("%d",&arr[i]);
printf("Enter The Element To Be Searched :");
scanf("%d",&x);
start=clock();
}
}
PAGE NO:
index=binary_search(arr,0,n-1,x);
end=clock();
if(index==-1)
{
printf("%d found at index\n",x);
}
else
{
}
printf("%d Found At Index %d In The List \n",x);
time_taken=((double)(end-start))/CLOCKS_PER_SEC;
printf("Time Taken For Binary Search :%f seconds\n",time_taken);
return 0;
RESULT:
PAGE NO:
PAGE NO:
DATE:
EX.NO:3 Given a text txt [0...n-1] and a pattern pat [0...m-
1], write a function search (char pat [ ], char txt [ ]) that
prints all occurrences of pat [ ] in txt [ ]. You may assume
that n > m.
AIM:
ALGORITHM:
PROGRAM:
#include<stdio.h>
#include<string.h>
int match(char[],char[]);
int main()
{
char a[100],b[100];
int position;
printf("Enter Some Text\n");
gets(a);
printf("Enter A String To Find\n");
gets(b);
position=match(a,b);
if(position!=-1)
{
printf("Found At Location :%d\n",position+1);
}
else
{
printf("Not Found\n");
}
return 0;
PAGE NO:
}
int match(char text[], char pattern[])
{
intc,d,e,text_length,pattern_length,position=-1;
position=-1;
text_length=strlen(text);
pattern_length=strlen(pattern);
if(pattern_length>text_length)
{
return-1;
}
for(c=0;c<=text_length-pattern_length;c++)
{
position=e=c;
for(d=0;d<pattern_length;d++)
{
if(pattern[d]==text[e])
{
e++;
}
else
{
break;
PAGE NO:
}
}
}
if(d==pattern_length)
{
return position;
}
}
return -1;
PAGE NO:
RESULT:
PAGE NO:
PAGE NO:
DATE:
EX.NO:4 Sort a given set of elements using the Insertion
sort and Heap sort methods and determine the time
required to sort the elements. Repeat the experiment for
different values of n, the number of elements in the list to
be sorted and plot a graph of the time taken versus n.
AIM:
ALGORITHM:
PROGRAM:
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
voidInsertionSort(intarr[],int n)
{
inti,j,key;
for(i=1;i<n;i++)
{
key=arr[i];
j=i-1;
while(j>=0&&arr[j]>key)
{
arr[j+1]=arr[j]; }
arr[j+1]=key;
}
}
voidheapify(intarr[], intn,int i)
{
int largest=i;
int l=2*i+1;
int r=2*i+2;
PAGE NO:
if(l<n&&arr[i]>arr[largest])
largest=1;
if(r<n&&arr[r]>arr[largest])
largest=r;
if(largest!=i)
{
int temp=arr[i];
arr[i]=arr[largest];
arr[largest]=temp;
heapify(arr,n,largest);
}
}
voidheapsort(intarr[],intn,int i)
{
for(i=n/2-1;i>=0;i--)
heapify(arr,n,i);
for(i=n-1;i>=0;i--)
{int temp=arr[0];
arr[0]=arr[i];
arr[i]=temp;
heapify(arr,i,0);
}
}
PAGE NO:
PAGE NO:
int main()
{
intn,i;
clock_tstart,end;
doubleCPU_time_used;
printf("Enter The Number Of Elements :");
scanf("%d",&n);
intarr[n];
for(i=0;i<n;i++)
arr[i]=rand()%100;
start=clock();
InsertionSort(arr,n);
end=clock();
CPU_time_used=((double)(end-start))/CLOCKS_PER_SEC;
printf("Time Taken By Insertion Sort :%f seconds\n",CPU_time_used);
return 0;
}
RESULT:
PAGE NO:
PAGE NO:
DATE:
EX.NO:5 Develop a program to implement graph traversal
using Breadth First Search.
AIM:
.
ALGORITHM:
PROGRAM:
#include<stdio.h>
#include<stdlib.h>
#define SIZE 10
// function to add an edge in the graph
voidaddEdge(intadjMatrix[][SIZE], int u, int v) {
adjMatrix[u][v] = 1;
adjMatrix[v][u] = 1;
}
// function to perform breadth first search traversal
voidbfs(intadjMatrix[][SIZE], int visited[], int start, int n) {
int queue[SIZE], front = 0, rear = 0, u;
visited[start] = 1;
queue[rear] = start;
while (front <= rear) {
u = queue[front];
printf("%d ", u);
front++;
int v;
for(v = 0; v < n; v++) {
PAGE NO:
if(adjMatrix[u][v] == 1 && visited[v] == 0) {
visited[v] = 1;
rear++;
queue[rear] = v;
}
}}
}
int main() {
intadjMatrix[SIZE][SIZE] = {0}, visited[SIZE] = {0}, n, e, u, v, start;
printf("Enter the number of nodes: ");
scanf("%d", &n);
printf("Enter the number of edges: ");
scanf("%d", &e);
int i;
for(i = 0; i < e; i++) {
printf("Enter edge %d: ", i+1);
scanf("%d%d", &u, &v);
addEdge(adjMatrix, u, v);
}
printf("Enter the starting node for BFS traversal: ");
scanf("%d", &start);
printf("BFS traversal is: ");
bfs(adjMatrix, visited, start, n);
PAGE NO:
return}
0;
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:6 Develop a program to implement graph traversal
using Depth First Search.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <stdbool.h>
#define MAX_SIZE 100
intadj[MAX_SIZE][MAX_SIZE];
int n; // number of vertices
bool visited[MAX_SIZE];
voiddfs(int v)
{
visited[v] = true;
printf("%d ", v);
int i;
for ( i = 0; i < n; i++)
{
if (adj[v][i] && !visited[i])
dfs(i);
}}
int main()
{
int m;
printf("Enter the number of vertices: ");
scanf("%d", &n);
printf("Enter the number of edges: ");
PAGE NO:
scanf("%d", &m);
inti,j;
// initialize the adjacency matrix with 0
for ( i = 0; i < n; i++)
{
for ( j = 0; j < n; j++)
{
adj[i][j] = 0;
}}
for (i = 0; i < m; i++)
{
int u, v;
printf("Enter the endpoints of edge %d: ", i+1);
scanf("%d %d", &u, &v);adj[u][v] = 1;
adj[v][u] = 1;
}
for (i = 0; i < n; i++)
{
visited[i] = false;
}
printf("DFS Traversal: ");
for (i = 0; i < n; i++)
{
PAGE NO:
if (!visited[i])
dfs(i);
}
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:7 From a given vertex in a weighted connected
graph, develop a program to find the shortest paths to
other vertices using Dijkstra’s algorithm.
AIM:
ALGORITHM:
PAGE NO:
PROGRAM:
#include <stdio.h>
#include <stdbool.h>
#include <limits.h>
#define V 5
intminDistance(intdist[], bool sptSet[])
{
int min = INT_MAX, min_index;
int v;
for ( v = 0; v < V; v++)
if (sptSet[v] == false &&dist[v] <= min)
min = dist[v], min_index = v;
returnmin_index;
}
voidprintSolution(intdist[])
{
printf("Vertex \t Distance from Source\n");
int i;
for ( i = 0; i < V; i++)
printf("%d \t\t %d\n", i, dist[i]);
}
voiddijkstra(int graph[V][V], intsrc)
{
PAGE NO:
intdist[V];
boolsptSet[V];
int i;
for ( i = 0; i < V; i++)
dist[i] = INT_MAX, sptSet[i] = false;
dist[src] = 0;
int count;
for ( count = 0; count < V - 1; count++)
{
int u = minDistance(dist, sptSet);
sptSet[u] = true;
int v;
for (v = 0; v < V; v++)
{
if (!sptSet[v] && graph[u][v] &&dist[u] != INT_MAX &&dist[u] + graph[u][v]
<dist[v])
dist[v] = dist[u] + graph[u][v];
}}
printSolution(dist);
}
int main()
{
int graph[V][V] = {
{0, 2, 0, 3, 0},{2, 0, 4, 0, 0},{0, 4, 0, 1, 5},
{3, 0, 1, 0, 7},{0, 0, 5, 7, 0}};
intsrc = 0; // Source vertex
dijkstra(graph, src);
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:8 Find the minimum cost spanning tree of a given
undirected graph using Prim’s algorithm.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <limits.h>
#define V 5
intminKey(int key[], intmstSet[]) {
int min = INT_MAX, min_index;
int v;
for ( v = 0; v < V; v++)
if (mstSet[v] == 0 && key[v] < min)
min = key[v], min_index = v;
returnmin_index;
}
voidprintMST(int parent[], int graph[V][V]) {
printf("Edge \tWeight\n");
int i;
for ( i = 1; i < V; i++)
printf("%d - %d \t%d \n", parent[i], i, graph[i][parent[i]]);
}
voidprimMST(int graph[V][V]) {
int parent[V];
PAGE NO:
int key[V];
intmstSet[V];
inti,count;
for ( i = 0; i < V; i++)
key[i] = INT_MAX, mstSet[i] = 0;
key[0] = 0;
parent[0] = -1;
for ( count = 0; count < V-1; count++) {
int u = minKey(key, mstSet);
mstSet[u] = 1;
int v;
for ( v = 0; v < V; v++)
if (graph[u][v] &&mstSet[v] == 0 && graph[u][v] < key[v])
parent[v] = u, key[v] = graph[u][v];
}
printMST(parent, graph);
}
int main()
{
int graph[V][V] = {{0, 2, 0, 6, 0},
{2, 0, 3, 8, 5},
{0, 3, 0, 0, 7},
{6, 8, 0, 0, 9},
PAGE NO:
{0, 5, 7, 9, 0}};
primMST(graph);
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:9 Implement Floyd’s algorithm for the All-Pairs-
Shortest-Paths problem.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <limits.h>
#define V 4
voidprintSolution(intdist[][V]);
voidfloydWarshall(int graph[][V])
{
intdist[V][V], i, j, k;
for (i = 0; i < V; i++)
for (j = 0; j < V; j++)
dist[i][j] = graph[i][j];
for (k = 0; k < V; k++)
{
for (i = 0; i < V; i++)
{
for (j = 0; j < V; j++)
{
if (dist[i][k] + dist[k][j] <dist[i][j])
dist[i][j] = dist[i][k] + dist[k][j];
}
}
}
PAGE NO:
printSolution(dist);
}
PAGE NO:
voidprintSolution(intdist[][V])
{
printf ("The following matrix shows the shortest distances between every pair
of vertices: \n");
inti,j;
for ( i = 0; i < V; i++)
{
for ( j = 0; j < V; j++)
{
if (dist[i][j] == INT_MAX)
printf("%7s\t", "INF");
else
printf ("%7d\t", dist[i][j]);
}
printf("\n");
}}
int main()
{
int graph[V][V] = {{0, 5, INT_MAX, 10},
{INT_MAX, 0, 3, INT_MAX},
{INT_MAX, INT_MAX, 0, 1},
{INT_MAX, INT_MAX, INT_MAX, 0}};
floydWarshall(graph);
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:10 Compute the transitive closure of a given
directed graph using Warshall's algorithm.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#define MAX_VERTICES 100
intadjacency_matrix[MAX_VERTICES][MAX_VERTICES];
intnum_vertices;
PAGE NO:
voidcompute_transitive_closure() {
int i, j, k;
for (k = 0; k <num_vertices; k++) {
for (i = 0; i <num_vertices; i++) {
for (j = 0; j <num_vertices; j++) {
adjacency_matrix[i][j] = adjacency_matrix[i][j] || (adjacency_matrix[i][k]
&&adjacency_matrix[k][j]);
}
}
}
}
voidprint_adjacency_matrix() {
int i, j;
printf("Adjacency Matrix:\n");
for (i = 0; i <num_vertices; i++) {
for (j = 0; j <num_vertices; j++) {
printf("%d ", adjacency_matrix[i][j]);
}
printf("\n");
}
}
int main() {
int i, j;
printf("Enter the number of vertices in the graph: ");
scanf("%d", &num_vertices);
printf("Enter the adjacency matrix:\n");
for (i = 0; i <num_vertices; i++) {
for (j = 0; j <num_vertices; j++) {
scanf("%d", &adjacency_matrix[i][j]);
}
}
compute_transitive_closure();
print_adjacency_matrix();
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
PAGE NO:
DATE:
EX.NO:11 Develop a program to find out the maximum and
minimum numbers in a given list of n numbers using the
divide and conquer technique.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
voidfindMinMax(intarr[], int low, int high, int* min, int* max) {
int mid, min1, min2, max1, max2;
if (low == high) {
*min = arr[low];
*max = arr[low];
return;
}
if (high == low + 1) {
if (arr[low] <arr[high]) {
*min = arr[low];
*max = arr[high];
} else {
*min = arr[high];
*max = arr[low];
}
return;
}
PAGE NO:
mid = (low + high) / 2;
findMinMax(arr, low, mid, &min1, &max1);
findMinMax(arr, mid + 1, high, &min2, &max2);
if (min1 < min2) {
*min = min1;
} else {
*min = min2;
}
if (max1 > max2) {
*max = max1;
} else {
*max = max2;
}
}
int main() {
int n, arr[100], i, min, max;
printf("Enter the number of elements: ");
scanf("%d", &n);
printf("Enter the elements: ");
for (i = 0; i < n; i++) {
scanf("%d", &arr[i]);
}
findMinMax(arr, 0, n - 1, &min, &max);
printf("Minimum element is %d\n", min);
PAGE NO:
printf("Maximum element is %d\n", max);
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:12 Implement Merge sort and Quick sort methods to
sort an array of elements and determine the time required
to sort. Repeat the experiment for different values of n, the
number of elements in the list to be sorted and plot a graph
of the time taken versus n.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
void merge(int arr[], int left, int mid, int right) {
int i, j, k;
int n1 = mid - left + 1;
int n2 = right - mid;
int L[n1], R[n2];
for (i = 0; i < n1; i++)
L[i] = arr[left + i];
for (j = 0; j < n2; j++)
R[j] = arr[mid + 1 + j];
i = 0;
j = 0;
k = left;
while (i < n1 && j < n2) {
if (L[i] <= R[j]) {
arr[k] = L[i];
i++;
}
else {
arr[k] = R[j];
PAGE NO:
j++;
}
k++;
}
while (i < n1) {
arr[k] = L[i];
i++;
k++;
}
while (j < n2) {
arr[k] = R[j];
j++;
k++;
}
}
void mergeSort(int arr[], int left, int right) {
if (left < right) {
int mid = left + (right - left) / 2;
mergeSort(arr, left, mid);
mergeSort(arr, mid + 1, right);
merge(arr, left, mid, right);
}
}
PAGE NO:
int partition(int arr[], int low, int high) {
int pivot = arr[high];
int i = (low - 1);
int j;
for ( j = low; j <= high - 1; j++) {
if (arr[j] < pivot) {
i++;
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
int temp = arr[i + 1];
arr[i + 1] = arr[high];
arr[high] = temp;
return (i + 1);
}
void quickSort(int arr[], int low, int high) {
if (low < high) {
int pi = partition(arr, low, high);
quickSort(arr, low, pi - 1);
quickSort(arr, pi + 1, high);
}
PAGE NO:
PAGE NO:
}
int main() {
int n;
printf("Enter the number of elements in the array: ");
scanf("%d", &n);
int arr[n];
srand(time(NULL));
int i;
for ( i = 0; i < n; i++) {
arr[i] = rand() % 10000;
}
clock_t start, end;
double cpu_time_used;
// Merge Sort
start = clock();
mergeSort(arr, 0, n - 1);
end = clock();
cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
printf("Time taken by Merge Sort: %f seconds\n", cpu_time_used);
// Quick Sort
start = clock();
quickSort(arr, 0, n - 1);
end = clock();
}
cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
printf("Time taken by Quick Sort: %f seconds\n", cpu_time_used);
return 0;
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:13 Implement N Queens problem using Backtracking.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <stdbool.h>
#define N 8
void printBoard(int board[N][N]) { int i,j;
for ( i = 0; i < N; i++) {
for ( j = 0; j < N; j++) {
printf("%d ", board[i][j]);
}
printf("\n");
}}
bool isSafe(int board[N][N], int row, int col) {
int i, j;
for (i = 0; i < col; i++) {
if (board[row][i]) {
return false;
}
}
for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {
if (board[i][j]) {
return false;
}}
for (i = row, j = col; j >= 0 && i < N; i++, j--) {
PAGE NO:
if (board[i][j]) {
return false;
}}
return true; }
bool solveNQueens(int board[N][N], int col) {
if (col >= N) {
return true;
}
int i;
for ( i = 0; i < N; i++) {
if (isSafe(board, i, col)) {
board[i][col] = 1;
if (solveNQueens(board, col + 1)) {
return true; }
board[i][col] = 0;
}}
return false;
}
int main() {
int board[N][N] = {0};
if (solveNQueens(board, 0)) {
printf("Solution found:\n");
printBoard(board);
PAGE NO:
}
} else {
printf("Solution not found.\n");
}
return 0;
PAGE NO:
RESULT:
PAGE NO:
DATE:
EX.NO:14 Implement any scheme to find the optimal
solution for the Traveling Salesperson problem and then
solve the same problem instance using any approximation
algorithm and determine the error in the approximation.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#define MAX_POINTS 10
typedef struct {
int x;
int y;
} Point;
PAGE NO:
double distance(Point p1, Point p2) {
int dx = p2.x - p1.x;
int dy = p2.y - p1.y;
return sqrt(dx*dx + dy*dy);
}
double tsp_optimal(Point points[], int num_points) {
int i, j, k;
int num_permutations = 1 << num_points; // 2^num_points
double min_distance = INT_MAX;
for (i = 1; i < num_permutations; i++) {
int visited[MAX_POINTS] = {0};
int current_point = 0; // Starting point is always 0
int count = 1; // Count of visited points
double path_distance = 0.0;
PAGE NO:
}
visited[current_point] = 1;
for (j = 1; j < num_points; j++) {
if ((i & (1 << j)) && !visited[j]) {
path_distance += distance(points[current_point], points[j]);
current_point = j;
visited[current_point] = 1;
count++;
}
}
if (count == num_points && path_distance < min_distance) {
path_distance += distance(points[current_point], points[0]);
min_distance = path_distance;
}
return min_distance;
}
double tsp_approximation(Point points[], int num_points) {
int visited[MAX_POINTS] = {0};
int current_point = 0;
visited[current_point] = 1;
double total_distance = 0.0;
int i;
for (i = 0; i < num_points - 1; i++) {
int next_point = -1;
double min_distance = INT_MAX;
int j;
for (j = 1; j < num_points; j++) {
if (!visited[j] && distance(points[current_point], points[j]) <
min_distance) {
min_distance = distance(points[current_point], points[j]);
next_point = j;
}
}
visited[next_point] = 1;
total_distance += min_distance;
current_point = next_point;
}
total_distance += distance(points[current_point], points[0]);
PAGE NO:
}
return total_distance;
PAGE NO:
int main() {
int num_points;
printf("Enter the number of points: ");
scanf("%d", &num_points);
Point points[MAX_POINTS];
printf("Enter the coordinates of the points:\n");
int i;
for (i = 0; i < num_points; i++) {
printf("Point %d: ", i);
scanf("%d %d", &points[i].x, &points[i].y);
}
double optimal_distance = tsp_optimal(points, num_points);
double approximation_distance = tsp_approximation(points, num_points);
printf("Optimal Distance: %.2f\n", optimal_distance);
printf("Approximation Distance: %.2f\n", approximation_distance);
return 0;
}
RESULT:
PAGE NO:
PAGE NO:
DATE:
EX.NO:15 Implement randomized algorithms for finding the
kth smallest number.
AIM:
ALGORITHM:
PROGRAM:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
void swap(int* a, int* b)
{
int temp = *a;
*a = *b;
*b = temp;
}
int partition(int arr[], int low, int high)
{
int pivot = arr[high];
int i = low - 1;
int j;
for ( j = low; j < high; j++) {
if (arr[j] <= pivot) {
i++;
swap(&arr[i], &arr[j]);
}
}
swap(&arr[i + 1], &arr[high]);
PAGE NO:
return i + 1;
}
int randomizedSelect(int arr[], int low, int high, int k)
{
if (low == high) {
return arr[low];
}
int pivotIndex = rand() % (high - low + 1) + low;
swap(&arr[pivotIndex], &arr[high]);
pivotIndex = partition(arr, low, high);
if (k == pivotIndex) {
return arr[k];
}
else if (k < pivotIndex) {
return randomizedSelect(arr, low, pivotIndex - 1, k);
}
else {
return randomizedSelect(arr, pivotIndex + 1, high, k);
}
}
PAGE NO:
int main()
{
int arr[] = { 3, 1, 7, 4, 5, 9, 2 };
int n = sizeof(arr) / sizeof(arr[0]);
srand(time(NULL));
int k = rand() % n;
printf("Original array: ");
int i;
for (i = 0; i < n; i++) {
printf("%d ", arr[i]);
}
printf("\n");
printf("k = %d\n", k);
int kthSmallest = randomizedSelect(arr, 0, n - 1, k);
printf("kth smallest element: %d\n", kthSmallest);
return 0;
}
PAGE NO:
RESULT:
PAGE NO:
