(1)Design a Lexical analyzer to recognize a few pattern in C.The lexical analyzer should ignore redundant spaces, tabs and new lines, comments etc.


program :

LEX PART :
%{
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAX_IDENTIFIER_LENGTH 50
%}
%option noyywrap
%option yylineno
void addtosymboltable(const char*)
%%
[\t] /*ignore whitespace*/
\n /*ignore newline*/
\/\*([^*]|\*+[^*/])*\*+\/ /*ignore comments*/
[0-9]+ {printf("Constant:%s \n",yytext);}
= {printf("%s is an Assignment Operator\n",yytext);}
\* |
\+ |
\- {printf("%s is a Operator\n",yytext);}
[a-zA-Z][a-zA-Z0-9]* {printf("identifier:%s\n",yytext);addtosymboltable(yytext);}
. {printf("Invalid token:%s \n",yytext);}
%%
typedef struct
{
char name[MAX_IDENTIFIER_LENGTH];
} Symbol;
Symbol symbol_table[100];
int symbol_count=0;
void addtosymboltable(const char * identifier){
if(symbol_count < 100)
{
strncpy(symbol_table[symbol_count].name,identifier,MAX_IDENTIFIER_LENGTH-1);
symbol_table[symbol_count].name[MAX_IDENTIFIER_LENGTH-1]='\0';
symbol_count++;
printf("Identifier %s is entered in the symbol table\n",identifier);
}
else
{
printf("Symbol table is full.Cannot add more identifier.\n");
exit(0);
}
}
int main()
{
yylex();
return 1;
}



Output :

a=c*5
identifier:a
Identifier a is entered in the symbol table
= is an Assignment Operator
identifier:c
Identifier c is entered in the symbol table
* is a Operator
Constant:5





(2)Implement the lexical analyzer using JLex, flex or other lexical analyzer generating tools.

Program :

%{
int COMMENT=0;
%}
identifier[a-zA-Z][a-zA-Z0-9]*
%%
#.* {printf("\n %s is a preprocessor directive",yytext);}
int |
float |
void |
main |
if |
else |
printf |
scanf |
for |
char |
getch |
while {printf("\n %s is a keyword",yytext);}
"/*" {COMMENT=1;}
"*/" {COMMENT=0;}
{identifier}\( {if(!COMMENT)printf("\n Function:\t %s",yytext);}
\{ {if(!COMMENT)printf("\n Block begins");}
\} {if(!COMMENT)printf("\n Block ends");}
{identifier}(\[[0-9]*\])? {if(!COMMENT)printf("\n %s is an Identifier",yytext);}
\".*\" {if(!COMMENT)printf("\n %s is a string",yytext);}
[0-9]+ {if(!COMMENT)printf("\n %s is a number",yytext);}
\)(\;)? {if(!COMMENT)printf("\t");ECHO;printf("\n");}
\(ECHO;
= {if(!COMMENT)printf("\n %s is an Assignment operator",yytext);}
\<= |
\>= |
\< |
== {if(!COMMENT)printf("\n %s is a relational operator",yytext);}
.|\n
%%
int main(int argc, char **argv)
{
if(argc>1)
{
FILE*file;
file=fopen(argv[1],"r");
if(!file)
{
printf("\n Could not open the file:%s ",argv[1]);
exit(0);
}
yyin=file;
}
yylex();
printf("\n\n");
return 0;
}
int yywrap()
{
return 0;
}


Output :

./a.out test.c                                      INT ✘  2m 59s 

 #include <stdio.h> is a preprocessor directive
 void is a keyword
 Function:       main(  )

 Block begins
 a is an Identifier
 = is an Assignment operator
 b is an Identifier
 c is an Identifier
 Function:       printf(
 "a is %d" is a string
 a is an Identifier     );

Parsing completed without errors.


(3)Write a program to implement to recognize a valid arithmetic expression that uses operator +, – , * and /.

Program :

LEX PART :
arith_id.l

%{
#include "ex3a.tab.h"
%}
%%
"=" {printf("\n Operator is EQUAL");}
"+" {printf("\n Operator is PLUS");}
"-" {printf("\n Operator is MINUS");}
"/" {printf("\n Operator is DIVISION");}
"*" {printf("\n Operator is MULTIPLICATION");}
[a-zA-Z]*[0-9]* {printf("\n Identifier is %s",yytext);return ID;}
. return yytext[0];
\n return 0;
%%
int yywrap()
{
return 1;
}


YACC PART :
arith_id.y

%{
#include<stdio.h>
%}
%token A
%token ID
%%
statement:A'='E
| E{
printf("\n Valid arithmetic expression");
$$=$1;
};
E:E'+'ID
|E'-'ID
|E'*'ID
|E'/'ID
|ID
;
%%
extern FILE *yyin;
main()
{
do
{
yyparse();
}while(!feof(yyin));
}
yyerror(char*s)
{
}


Output :

 ./a.out
a=b+c

 Identifier is a
 Operator is EQUAL
 Identifier is b
 Valid arithmetic expression
 Operator is PLUS
 Identifier is c
 Valid arithmetic expression


(4)Write a program to implement a Calculator using LEX and YACC.

Program :

LEX PART :

%{
#include <stdio.h>
#include "y.tab.h"
extern int yylval;
%}
%%
[0-9]+ {
yylval = atoi(yytext);
return NUMBER;
}
[ \t] ;
[\n] return 0;
. {return yytext[0];}
%%
int yywrap()
{
return 1;
}


YACC Part :

%{
#include <stdio.h>
int flag = 0;
%}
%token NUMBER
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'
%%
ArithmeticExpression: E {
printf("Result = %d\n", $1);
return 0;
};
E: E '+' E { $$ = $1 + $3; }
| E '-' E { $$ = $1 - $3; }
| E '*' E { $$ = $1 * $3; }
| E '/' E { $$ = $1 / $3; }
| E '%' E { $$ = $1 % $3; }
| '(' E ')' { $$ = $2; }
| NUMBER { $$ = $1; }
;
%%
int main()
{
printf("\nEnter an arithmetic expression that can have operations Addition, Subtraction, Multiplication,Division, Modulus and Round brackets: ");
yyparse();
if (flag == 0) {
printf("\nEntered arithmetic expression is Valid\n");
}
return 0;
}
void yyerror(const char* s)
{
printf("\nEntered arithmetic expression is Invalid\n");
flag = 1;
}


Output :

Enter an arithmetic expression that can have operations Addition,Subtraction,Multiplication,Division,Modulus and Round brackets :4+2+6*10
Result=66
Entered arithmetic expression is valid



(5)Write a Program to recognize a valid variable which starts with a letter followed by any number of letters or digits.

program :

LEX PART :
variable_lex.l

%{
#include "y.tab.h"
%}
%%
"int" {return INT;}
"float" {return FLOAT;}
"double" {return DOUBLE;}
[a-zA-Z]*[0-9]* {printf("\n Identifier is %s",yytext);return ID;}
. return yytext[0];
\n return 0;
%%

int yywrap() {
return 1;
}

YACC PART :
variable_parser.y


%{
#include<stdio.h>
%}
%token ID INT FLOAT DOUBLE
%%
D:T L
;
L:L ID
| ID
;
T:INT
| FLOAT
| DOUBLE
;
%%
extern FILE *yyin;
main()
{
do
{
yyparse();
}while(!feof(yyin));
}
yyerror(char*s)
{
}


Compiling and Running:

lex variable_lex.l
yacc -d variable_parser.y
gcc lex.yy.c y.tab.c -o variable_parser -ll
./variable_parser

Output :

example123
Valid variable: example123



(6)Write a LEX Program to convert the substring abc to ABC from the given input string.


Program :

LEX PART :
convert_lex.l

%{

int i;
%}
%%
[a-z A-Z]* {
for(i=0;i<=yyleng;i++)
{
if((yytext[i]=='a')&&(yytext[i+1]=='b')&&(yytext[i+2]=='c'))
{
yytext[i]='A';
yytext[i+1]='B';
yytext[i+2]='C';
}
}
printf("%s",yytext);
}
[\t]* return;
.* {ECHO;}
\n {printf("%s",yytext);}
%%
main()
{
yylex();
}
int yywrap()
{
return 1;
}



Compiling and Running:

lex convert_lex.l
yacc -d convert_parser.y
gcc lex.yy.c y.tab.c -o convert_parser -ll
./convert_parser


Output :

abc abc123
ABC ABC123



(7)Write a C Program to implement NFAs that recognize identifiers, constants, and operators of the mini language.


Program :

#include <stdio.h>
#include <regex.h>

int main() {
    regex_t identifier_regex, constant_regex, operator_regex;

    // Regular expressions for identifiers, constants, and operators
    const char *identifier_pattern = "[a-zA-Z_][a-zA-Z0-9_]*";
    const char *constant_pattern = "[0-9]+";
    const char *operator_pattern = "[+\\-*/]";

    // Compile the regular expressions
    regcomp(&identifier_regex, identifier_pattern, REG_EXTENDED);
    regcomp(&constant_regex, constant_pattern, REG_EXTENDED);
    regcomp(&operator_regex, operator_pattern, REG_EXTENDED);

    // Input strings
    const char *inputs[] = {
        "variable123",
        "123",
        "+",
        "invalid123$",
        "12.34"
    };

    // Match and print results
    for (int i = 0; i < sizeof(inputs) / sizeof(inputs[0]); i++) {
        if (regexec(&identifier_regex, inputs[i], 0, NULL, 0) == 0) {
            printf("%s is an identifier.\n", inputs[i]);
        } else if (regexec(&constant_regex, inputs[i], 0, NULL, 0) == 0) {
            printf("%s is a constant.\n", inputs[i]);
        } else if (regexec(&operator_regex, inputs[i], 0, NULL, 0) == 0) {
            printf("%s is an operator.\n", inputs[i]);
        } else {
            printf("%s is not recognized.\n", inputs[i]);
        }
    }

    // Free resources
    regfree(&identifier_regex);
    regfree(&constant_regex);
    regfree(&operator_regex);

    return 0;
}


Output :


variable123 is an identifier.
123 is a constant.
+ is an operator.
invalid123$ is not recognized.
12.34 is not recognized.



(8)Write a C Program to implement DFA's that recognize identifiers, constants, and operators of the mini language.

Program :

#include <stdio.h>
#include <stdbool.h>
#include <ctype.h>

// Enumeration for different token types
enum TokenType {
    IDENTIFIER,
    CONSTANT,
    OPERATOR,
    INVALID
};

// Function to check if a character is a valid identifier character
bool isIdentifierChar(char ch) {
    return isalpha(ch) || isdigit(ch) || ch == '_';
}

// Function to recognize tokens using a DFA
enum TokenType recognizeToken(const char *input) {
    int state = 0;

    for (int i = 0; input[i] != '\0'; i++) {
        char ch = input[i];

        switch (state) {
            case 0:
                if (isalpha(ch) || ch == '_') {
                    state = 1;
                } else if (isdigit(ch)) {
                    state = 2;
                } else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
                    state = 3;
                } else {
                    return INVALID;
                }
                break;

            case 1:
                if (!isIdentifierChar(ch)) {
                    return INVALID;
                }
                break;

            case 2:
                if (!isdigit(ch)) {
                    return INVALID;
                }
                break;

            case 3:
                // Operators are only one character
                return OPERATOR;
        }
    }

    switch (state) {
        case 1: return IDENTIFIER;
        case 2: return CONSTANT;
        case 3: return OPERATOR;
        default: return INVALID;
    }
}

// Function to print token type
void printTokenType(enum TokenType type) {
    switch (type) {
        case IDENTIFIER: printf("Identifier\n"); break;
        case CONSTANT:   printf("Constant\n"); break;
        case OPERATOR:   printf("Operator\n"); break;
        case INVALID:    printf("Invalid\n"); break;
    }
}

int main() {
    const char *inputs[] = {
        "variable123",
        "123",
        "+",
        "invalid123$",
        "12.34"
    };

    for (int i = 0; i < sizeof(inputs) / sizeof(inputs[0]); i++) {
        enum TokenType type = recognizeToken(inputs[i]);
        printf("%s is a ", inputs[i]);
        printTokenType(type);
    }

    return 0;
}


Output :

variable123 is a Identifier
123 is a Constant
+ is a Operator
invalid123$ is a Invalid
12.34 is a Invalid



(9)Write a program to Implement Simple Code Optimization Techniques using Constant Folding.

Program :

#include<stdio.h>
#include<string.h>
struct op
{
char l;
char r[20];
}
op[10],pr[10];
void main() {
int a,i,k,j,n,z=0,m,q;
char *p,*l;
char temp,t;
char *tem;
printf("Enter the Number of Values:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
printf("left: ");
scanf(" %c",&op[i].l);
printf("right: ");
scanf(" %s",&op[i].r);
}
printf("Intermediate Code") ;
for(i=0;i<n;i++)
{
printf("%c=",op[i].l);
printf("%s",op[i].r);
}
for(i=0;i<n-1;i++)
{
temp=op[i].l;
for(j=0;j<n;j++)
{
p=strchr(op[j].r,temp);
if(p)
{
pr[z].l=op[i].l;
strcpy(pr[z].r,op[i].
r);
z++;
}
}
}
pr[z].l=op[n-1].l;
strcpy(pr[z].r,op[n-1].r);
z++;
printf("After Dead Code Elimination");
for(k=0;k<z;k++)
{
printf("%c=",pr[k].l);
printf("%s",pr[k].r);
}
for(m=0;m<z;m++)
{
tem=pr[m].r;
for(j=m+1;j<z;j++)
{
p=strstr(tem,pr[j].r);
if(p)
{
t=pr[j].l;
pr[j].l=pr[m].l;
for(i=0;i<z;i++)
{
l=strchr(pr[i].r,t) ;
if(l)
{
a=l-pr[i].r;
printf("pos: %d",a);
pr[i].r[a]=pr[m].l;
}}}}}
printf("Eliminate Common Expression");
for(i=0;i<z;i++)
{
printf("%c=",pr[i].l);
printf("%s",pr[i].r);
}
for(i=0;i<z;i++)
{
for(j=i+1;j<z;j++)
{
q=strcmp(pr[i].r,pr[j].r);
if((pr[i].l==pr[j].l)&&!q)
{
pr[i].l="";
}
}
}
printf("Optimized Code");
for(i=0;i<z;i++)
{
if(pr[i].l!="")
{
printf("%c=",pr[i].l);
printf("%s",pr[i].r);
}
}
}




Output :
Enter the Number of Values:2
left: a
right: 9
left: b
right: c+d
Intermediate Codea=9b=c+dAfter Dead Code Eliminationb=c+dEliminate Common Expressionb=c+dOptimized Codeb=c+d%



(10)Write a program to Implement the back end of the compiler which takes the three address code and produces the 8086 assembly language instructions that can be assembled and run using a 8086 assembler. The target assembly instructions can be simple move, add, sub, jump. Also simple addressing modes are used.


Program :

//original
#include <stdio.h>
#include <stdio.h>
#include<conio.h>
#include <string.h>
void main() {
char icode[10][30], str[20], opr[10];
int i = 0;
clrscr();
printf(" Enter the set of intermediate code (terminated by exit):");
do
{
scanf("%s", icode[i]);
} while (strcmp(icode[i++], "exit") != 0);
printf("target code generation");
printf("************************");
i = 0;
do {
strcpy(str, icode[i]);
switch (str[3]) {
case '+':
strcpy(opr, "ADD ");
break;
case '-':
strcpy(opr, "SUB ");
break;
case '*':
strcpy(opr, "MUL ");
break;
case '/':
strcpy(opr, "DIV ");
break;
}
printf("Mov %c,R%d", str[2], i);
printf("%s%c,R%d", opr, str[4], i);
printf("Mov R%d,%c", i, str[0]);
} while (strcmp(icode[++i], "exit") != 0);
getch();
}

//new

#include <stdio.h>
void generateAssembly(int op, int arg1, int arg2, int result) {
    switch (op) {
        case 0: // Assignment
            printf("MOV AX, [%d]\n", arg1);
            printf("MOV [%d], AX\n", result);
            break;

        case 1: // Addition
            printf("MOV AX, [%d]\n", arg1);
            printf("ADD AX, [%d]\n", arg2);
            printf("MOV [%d], AX\n", result);
            break;

        case 2: // Subtraction
            printf("MOV AX, [%d]\n", arg1);
            printf("SUB AX, [%d]\n", arg2);
            printf("MOV [%d], AX\n", result);
            break;

        case 3: // Jump
            printf("JMP L%d\n", arg1);
            break;

        default:
            printf("Invalid operation\n");
            break;
    }
}

int main() {
    // Sample three-address code
    generateAssembly(0, 1000, 0, 2000); // a = b
    generateAssembly(1, 2000, 3000, 4000); // c = a + d
    generateAssembly(2, 4000, 5000, 6000); // e = c - f
    generateAssembly(3, 7000, 0, 0); // Jump to label 0

    return 0;
}


Output :

//old
Enter the set of intermediate code (terminated by exit):
a=a*b
c=f*h
g=a*h
f=Q+w
t=q-j
exit
target code generation
************************
Mov a,R0
MUL b,R0
Mov R0,a
Mov f,R1
MUL h,R1
Mov R1,c
Mov a,R2
MUL h,R2
Mov R2,g
Mov Q,R3
ADD w,R3
Mov R3,f
Mov q,R4
SUB j,R4
Mov R4,t


//new
MOV AX, [1000]
MOV [2000], AX
MOV AX, [2000]
ADD AX, [3000]
MOV [4000], AX
MOV AX, [4000]
SUB AX, [5000]
MOV [6000], AX
JMP L0



(11)Write a lex program to find out total number of vowels, and consonants from the given input string.

Program :
LEX PART :



%{
    #include <stdio.h>
    int vowel_count = 0;
    int consonant_count = 0;
%}

%%
[aeiouAEIOU]   { vowel_count++; }
[a-zA-Z]       { consonant_count++; }
.              { /* Ignore other characters */ }
%%

int main() {
    char input[100];  // Adjust the size as needed
    printf("Enter a string: ");

    // Read the input string directly
    if (fgets(input, sizeof(input), stdin) != NULL) {
        // Set the input buffer
        yy_scan_string(input);

        // Call the generated lexer function
        yylex();

        // Print the counts
        printf("Number of vowels: %d\n", vowel_count);
        printf("Number of consonants: %d\n", consonant_count);
    } else {
        fprintf(stderr, "Error reading input.\n");
    }

    return 0;
}

int yywrap() {
    return 1;  // Indicate the end of input
}

//old

%{
    #include <stdio.h>
    int vowel_count = 0;
    int consonant_count = 0;
%}

%%
[aeiouAEIOU]   { vowel_count++; }
[a-zA-Z]       { consonant_count++; }
.              { /* Ignore other characters */ }
%%

int main() {
    printf("Enter a string: ");

    // Set the input buffer to the user input
    yy_scan_string(gets(NULL));

    // Call the generated lexer function
    yylex();

    // Print the counts
    printf("Number of vowels: %d\n", vowel_count);
    printf("Number of consonants: %d\n", consonant_count);

    return 0;
}

int yywrap() {
    return 1;  // Indicate the end of input
}




Output :

Enter a string: Hello World
Total vowels: 3
Total consonants: 7



(12)Write a program to implement to recognize a valid control structures syntax of C language using For loop and while loop.

Program :

LEX PART: ex3c.l
%{
#include <stdio.h>
#include "y.tab.h"
%}

%%
"if"      { return IF; }
"else"    { return ELSE; }
"while"   { return WHILE; }
"for"     { return FOR; }
"switch"  { return SWITCH; }
"case"    { return CASE; }
"default" { return DEFAULT; }
"break"   { return BREAK; }
"("       { return OPEN_BRACKET; }
")"       { return CLOSE_BRACKET; }
"{"       { return OPEN_BRACE; }
"}"       { return CLOSE_BRACE; }
";"       { return SEMICOLON; }
[\t\n]    ;  // Ignore tabs and newlines
.        ;  // Ignore other characters
%%

int yywrap()
{
    return 1;
}



YACC PART: ex3c.y
%{
#include<stdio.h>
int yylex();
%}
%token IF ELSE WHILE FOR SWITCH CASE DEFAULT OPEN_BRACE CLOSE_BRACE
SEMICOLON COLON OPEN_BRACKET CLOSE_BRACKET BREAK
%%
program: statement
| program statement
;
statement:if_statement
|while_loop
|switch_case_statement
|for_loop
;
if_statement:IF OPEN_BRACKET expression_opt CLOSE_BRACKET OPEN_BRACE
expression_opt CLOSE_BRACE ELSE OPEN_BRACE expression_opt CLOSE_BRACE
{
printf("Recognized IF Else statement\n");
}
;
while_loop:WHILE OPEN_BRACKET expression_opt CLOSE_BRACKET OPEN_BRACE
expression_opt CLOSE_BRACE
{
printf("Recognized WHILE loop\n");
}
;
switch_case_statement:SWITCH OPEN_BRACKET expression_opt CLOSE_BRACKET
OPEN_BRACE case_list CLOSE_BRACE
{
printf("Recognized SWITCH_CASE statement with DEFAULT\n");
}
;
for_loop:FOR OPEN_BRACKET expression_opt SEMICOLON expression_opt
CLOSE_BRACKET OPEN_BRACE expression_opt CLOSE_BRACE
{
printf("Recognized FOR loop\n");
}
;
case_list:CASE expression COLON expression BREAK
SEMICOLON DEFAULT COLON expression_opt
;
expression_opt:/*empty*/
|expression
|expression SEMICOLON
;
expression:
;
%%
int yyerror(const char *s)
{
fprintf(stderr,"Error=%s\n", s);
return 1;
}
int main() {
if(yyparse()==0){
printf("Parsing completed successfully\n");
}
else{
fprintf(stderr,"Parsing encountered errors\n");
}
return 0;
}



Compiling and Running :

lex recognize_control.l
yacc -d recognize_control.y
gcc lex.yy.c y.tab.c -o recognize_control -ll
./recognize_control


Output :

Enter a control structure: for (;;) {



(13)Write a program to Convert the BNF rules into Yacc form and write code to generate abstract syntax tree.


Program :

LEX PART :
ast_lex.l


%{

#include"y.tab.h"

#include<stdio.h>

#include<string.h>

int LineNo=1;

%}

identifier [a-zA-Z][_a-zA-Z0-9]*

number [0-9]+|([0-9]*\.[0-9]+)

%%

main\(\) return MAIN;

if return IF;

else return ELSE;

while return WHILE;

int |

char |

float return TYPE;

{identifier} {strcpy(yylval.var,yytext);

return VAR;}

{number} {strcpy(yylval.var,yytext);

return NUM;}

\< |

\> |

\>= |

\<= |

== {strcpy(yylval.var,yytext);

return RELOP;}

[ \t] ;

\n LineNo++;

. return yytext[0];

%%


int yywrap() {
    return 1;  // Indicate the end of input
}



YACC PART :
ast_parser.y


%{

#include<string.h>

#include<stdio.h>

struct quad

{

char op[5];

char arg1[10];

char arg2[10];

char result[10];

}QUAD[30];

struct stack

{





int items[100];

int top;

}stk;

int Index=0,tIndex=0,StNo,Ind,tInd;

extern int LineNo;

%}

%union

{

char var[10];

}

%token <var> NUM VAR RELOP

%token MAIN IF ELSE WHILE TYPE

%type <var> EXPR ASSIGNMENT CONDITION IFST ELSEST WHILELOOP

%left '-' '+'

%left '*' '/'

%%

PROGRAM : MAIN BLOCK

;

BLOCK: '{' CODE '}'

;

CODE: BLOCK

| STATEMENT CODE

| STATEMENT

;

STATEMENT: DESCT ';'

| ASSIGNMENT ';'

| CONDST

| WHILEST

;

DESCT: TYPE VARLIST

;

VARLIST: VAR ',' VARLIST

| VAR

;

ASSIGNMENT: VAR '=' EXPR{

strcpy(QUAD[Index].op,"=");

strcpy(QUAD[Index].arg1,$3);

strcpy(QUAD[Index].arg2,"");

strcpy(QUAD[Index].result,$1);

strcpy($$,QUAD[Index++].result);

}

;

EXPR: EXPR '+' EXPR {AddQuadruple("+",$1,$3,$$);}

| EXPR '-' EXPR {AddQuadruple("-",$1,$3,$$);}

| EXPR '*' EXPR {AddQuadruple("*",$1,$3,$$);}

| EXPR '/' EXPR {AddQuadruple("/",$1,$3,$$);}

| '-' EXPR {AddQuadruple("UMIN",$2,"",$$);}

| '(' EXPR ')' {strcpy($$,$2);}

| VAR

| NUM





;

CONDST: IFST{

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

}

| IFST ELSEST

;

IFST: IF '(' CONDITION ')' {

strcpy(QUAD[Index].op,"==");

strcpy(QUAD[Index].arg1,$3);

strcpy(QUAD[Index].arg2,"FALSE");

strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

}

BLOCK { strcpy(QUAD[Index].op,"GOTO"); strcpy(QUAD[Index].arg1,"");

strcpy(QUAD[Index].arg2,"");

strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

};

ELSEST: ELSE{

tInd=pop();

Ind=pop();

push(tInd);

sprintf(QUAD[Ind].result,"%d",Index);

}

BLOCK{

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

};

CONDITION: VAR RELOP VAR {AddQuadruple($2,$1,$3,$$);

StNo=Index-1;

}

| VAR

| NUM

;

WHILEST: WHILELOOP{

Ind=pop();

sprintf(QUAD[Ind].result,"%d",StNo);

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

}

;

WHILELOOP: WHILE'('CONDITION ')' {

strcpy(QUAD[Index].op,"==");

strcpy(QUAD[Index].arg1,$3);

strcpy(QUAD[Index].arg2,"FALSE");





strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

}

BLOCK {

strcpy(QUAD[Index].op,"GOTO");

strcpy(QUAD[Index].arg1,"");

strcpy(QUAD[Index].arg2,"");

strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

}

;

%%

extern FILE *yyin;

int main(int argc,char *argv[])

{

FILE *fp;

int i;

if(argc>1)

{

fp=fopen(argv[1],"r");

if(!fp)

{

printf("\n File not found");

exit(0);

}

yyin=fp;

}

yyparse();

printf("\n\n\t\t ----------------------------""\n\t\t Pos Operator \tArg1 \tArg2 \tResult" "\n\t\t--------------------");

for(i=0;i<Index;i++)

{

printf("\n\t\t %d\t %s\t %s\t %s\t%s",i,QUAD[i].op,QUAD[i].arg1,QUAD[i].arg2,QUAD[i].result);

}

printf("\n\t\t -----------------------");

printf("\n\n"); return 0; }

void push(int data)

{ stk.top++;

if(stk.top==100)

{

printf("\n Stack overflow\n");

exit(0);

}

stk.items[stk.top]=data;

}

int pop()

{

int data;





if(stk.top==-1)

{

printf("\n Stack underflow\n");

exit(0);

}

data=stk.items[stk.top--];

return data;

}

void AddQuadruple(char op[5],char arg1[10],char arg2[10],char result[10])

{

strcpy(QUAD[Index].op,op);

strcpy(QUAD[Index].arg1,arg1);

strcpy(QUAD[Index].arg2,arg2);

sprintf(QUAD[Index].result,"t%d",tIndex++);

strcpy(result,QUAD[Index++].result);

}

yyerror()

{

printf("\n Error on line no:%d",LineNo);

}



Compilation and Running :
 main()

{

int a,b,c;

if(a<b)

{

a=a+b;

}

while(a<b)

{

a=a+b;

}

if(a<=b)

{

c=a-b;

}

else

{

c=a+b;

}

}

Output :

5 + 3 * (2 - 1)

  +
 / \
5   *
   / \
  3   -
     / \
    2   1



(14)Write a program to implement to recognize a valid control structures syntax of C language using ifelse, if-else-if and switch-case.


Program :

LEX PART :
recognize_control.l


%{
#include <stdio.h>
#include "y.tab.h"
%}

%%
"if"      { return IF; }
"else"    { return ELSE; }
"while"   { return WHILE; }
"for"     { return FOR; }
"switch"  { return SWITCH; }
"case"    { return CASE; }
"default" { return DEFAULT; }
"break"   { return BREAK; }
"("       { return OPEN_BRACKET; }
")"       { return CLOSE_BRACKET; }
"{"       { return OPEN_BRACE; }
"}"       { return CLOSE_BRACE; }
";"       { return SEMICOLON; }
[\t\n]    ;  // Ignore tabs and newlines
.        ;  // Ignore other characters
%%

int yywrap()
{
    return 1;
}



YACC PART: ex3c.y
%{
#include<stdio.h>
int yylex();
%}
%token IF ELSE WHILE FOR SWITCH CASE DEFAULT OPEN_BRACE CLOSE_BRACE
SEMICOLON COLON OPEN_BRACKET CLOSE_BRACKET BREAK
%%
program: statement
| program statement
;
statement:if_statement
|while_loop
|switch_case_statement
|for_loop
;
if_statement:IF OPEN_BRACKET expression_opt CLOSE_BRACKET OPEN_BRACE
expression_opt CLOSE_BRACE ELSE OPEN_BRACE expression_opt CLOSE_BRACE
{
printf("Recognized IF Else statement\n");
}
;
while_loop:WHILE OPEN_BRACKET expression_opt CLOSE_BRACKET OPEN_BRACE
expression_opt CLOSE_BRACE
{
printf("Recognized WHILE loop\n");
}
;
switch_case_statement:SWITCH OPEN_BRACKET expression_opt CLOSE_BRACKET
OPEN_BRACE case_list CLOSE_BRACE
{
printf("Recognized SWITCH_CASE statement with DEFAULT\n");
}
;
for_loop:FOR OPEN_BRACKET expression_opt SEMICOLON expression_opt
CLOSE_BRACKET OPEN_BRACE expression_opt CLOSE_BRACE
{
printf("Recognized FOR loop\n");
}
;
case_list:CASE expression COLON expression BREAK
SEMICOLON DEFAULT COLON expression_opt
;
expression_opt:/*empty*/
|expression
|expression SEMICOLON
;
expression:
;
%%
int yyerror(const char *s)
{
fprintf(stderr,"Error=%s\n", s);
return 1;
}
int main() {
if(yyparse()==0){
printf("Parsing completed successfully\n");
}
else{
fprintf(stderr,"Parsing encountered errors\n");
}
return 0;
}

Output :

Enter a control structure: if (x > 0) { } else if (x < 0) { } else { }



(15)Write a program to Implement any one storage allocation strategies.


#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;

    // Get the number of elements from the user
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    // Allocate memory for an integer array of size n
    int *arr = (int *)malloc(n * sizeof(int));

    // Check if memory allocation was successful
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // Exit with an error code
    }

    // Input elements from the user
    printf("Enter %d elements:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Display the entered elements
    printf("Entered elements: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Free the allocated memory
    free(arr);

    return 0;
}







(16)Write a program to Implement type checking.

Program :

 //To implement type checking
#include<stdio.h>
#include<stdlib.h>
int main()
{
int n,i,k,flag=0;
char vari[15],typ[15],b[15],c;
printf("Enter the number of variables:");
scanf(" %d",&n);
for(i=0;i<n;i++)
{
printf("Enter the variable[%d]:",i);
scanf(" %c",&vari[i]);
printf("Enter the variable-type[%d](float-f,int-i):",i);
scanf(" %c",&typ[i]);
if(typ[i]=='f')
flag=1;
}
printf("Enter the Expression(end with $):");
i=0;
getchar();
while((c=getchar())!='$')
{
b[i]=c;
i++;  }
k=i;
for(i=0;i<k;i++)
{
if(b[i]=='/')
{
flag=1;
break;  }  }
for(i=0;i<n;i++)
{
if(b[0]==vari[i])
{
if(flag==1)
{
if(typ[i]=='f')
{  printf("\nthe datatype is correctly defined..!\n");
break;  }
else
{  printf("Identifier %c must be a float type..!\n",vari[i]);
break;  }  }
else
{  printf("\nthe datatype is correctly defined..!\n");
break;  }  }
}
return 0;
}



Output :

./a.out
Enter the number of variables:3
Enter the variable[0]:a
Enter the variable-type[0](float-f,int-i):i
Enter the variable[1]:b
Enter the variable-type[1](float-f,int-i):i
Enter the variable[2]:c
Enter the variable-type[2](float-f,int-i):i
Enter the Expression(end with $):a=b+c$

the datatype is correctly defined..!



(17)Write a program to Implement Simple Code Optimization Techniques using Strength reduction.

Program :

#include <stdio.h>
int main() {
    int i;
    int n = 10;

    // Original code with multiplication
    printf("Original Code:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", i * 3);
    }
    printf("\n");

    // Code after strength reduction
    printf("\nCode after Strength Reduction:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", i << 1 + i);  // Replaced multiplication with shift and addition
    }

    return 0;
}



Output :

Original Code:
0 3 6 9 12 15 18 21 24 27

Code after Strength Reduction:
0 4 16 48 128 320 768 1792 4096 9216



(18)Write a program to implement to implement the symbol table.


Program :

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Symbol structure representing a variable in the symbol table
struct Symbol {
    char name[50];
    int value;
    struct Symbol* next;
};

// Symbol table structure
struct SymbolTable {
    struct Symbol* head;
};

// Function to create a new symbol
struct Symbol* createSymbol(char name[], int value) {
    struct Symbol* symbol = (struct Symbol*)malloc(sizeof(struct Symbol));
    strcpy(symbol->name, name);
    symbol->value = value;
    symbol->next = NULL;
    return symbol;
}

// Function to insert a symbol into the symbol table
void insertSymbol(struct SymbolTable* symbolTable, char name[], int value) {
    struct Symbol* symbol = createSymbol(name, value);
    symbol->next = symbolTable->head;
    symbolTable->head = symbol;
}

// Function to search for a symbol in the symbol table
struct Symbol* searchSymbol(struct SymbolTable* symbolTable, char name[]) {
    struct Symbol* current = symbolTable->head;
    while (current != NULL) {
        if (strcmp(current->name, name) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL; // Symbol not found
}

// Function to display the contents of the symbol table
void displaySymbolTable(struct SymbolTable* symbolTable) {
    struct Symbol* current = symbolTable->head;
    while (current != NULL) {
        printf("Name: %s, Value: %d\n", current->name, current->value);
        current = current->next;
    }
}

int main() {
    struct SymbolTable symbolTable;
    symbolTable.head = NULL;

    // Insert symbols into the symbol table
    insertSymbol(&symbolTable, "x", 10);
    insertSymbol(&symbolTable, "y", 20);
    insertSymbol(&symbolTable, "z", 30);

    // Display the symbol table
    printf("Symbol Table:\n");
    displaySymbolTable(&symbolTable);

    // Search for a symbol
    char searchName[50];
    printf("\nEnter a symbol to search: ");
    scanf("%s", searchName);
    struct Symbol* result = searchSymbol(&symbolTable, searchName);
    if (result != NULL) {
        printf("Symbol found - Name: %s, Value: %d\n", result->name, result->value);
    } else {
        printf("Symbol not found.\n");
    }

    return 0;
}






(19)Write a program to Implement Simple Code Optimization Techniques using Algebraic transformation.

Program :

#include <stdio.h>

int main() {
    int x = 5;
    int y = 3;
    int z = 7;

    // Original code
    int result1 = x * y + x * z;
    printf("Original Code: %d\n", result1);

    // Code after algebraic transformation
    int result2 = x * (y + z);
    printf("Code after Algebraic Transformation: %d\n", result2);

    return 0;
}


Output :

Original Code: 50
Code after Algebraic Transformation: 50



(20)Write a program to generate three address code using LEX and YACC.

Program :

LEX PART :
three_address_lex.l
LEX PART: ex4.l
%{
#include<stdio.h>
#include "ex4.tab.h"
%}
%%
[0-9]+ {yylval=atoi(yytext);return NUM;}
[\t] ;
\n {return EOL;}
[-+*/()] {return yytext[0];}
. {fprintf(stderr,"Error:Invalid Character\n");}
%%
int yywrap(){
return 1;
}



YACC PART: ex4.y
%{
#include<stdio.h>
#include<stdlib.h>
int temp_count=0;
void yyerror(const char*s){
fprintf(stderr,"Error:%s\n",s);
}
%}
%token NUM EOL
%left '+' '-'
%left '*' '/'
%%
program:lines
;
lines:lines line
| line
;
line:expr EOL
{
printf("Result:t%d\n",$1);
}
;
expr:NUM{
$$=$1;
}
| '(' expr ')'
{
$$=$2;
}
| expr '+' expr
{
printf("t%d=%d+%d\n",++temp_count,$1,$3);
$$=temp_count;
}
| expr '-' expr
{
printf("t%d=%d-%d\n",++temp_count,$1,$3);
$$=temp_count;
}
| expr '*' expr
{
printf("t%d=%d*%d\n",++temp_count,$1,$3);
$$=temp_count;
}
| expr '/' expr
{
if($3==0)
{yyerror("Division by zero");
$$=0;}
else{
printf("t%d=%d/%d\n",++temp_count,$1,$3);
$$=temp_count;
}
}
;
%%
int main()
{
yyparse();
return 0;
}

Output :

./a.out
2*10/2+5-1
t1=2*10
t2=1/2
t3=2+5
t4=3-1
Result:t4




